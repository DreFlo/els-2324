/*
 * generated by Xtext 2.32.0
 */
package org.feup.els5.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.feup.els5.dsl.services.TableDSLGrammarAccess;
import org.feup.els5.dsl.tableDSL.Extract;
import org.feup.els5.dsl.tableDSL.Filter;
import org.feup.els5.dsl.tableDSL.Output;
import org.feup.els5.dsl.tableDSL.RenameColumn;
import org.feup.els5.dsl.tableDSL.Select;
import org.feup.els5.dsl.tableDSL.SquashRows;
import org.feup.els5.dsl.tableDSL.Start;
import org.feup.els5.dsl.tableDSL.TableDSLPackage;
import org.feup.els5.dsl.tableDSL.TableInputPath;

@SuppressWarnings("all")
public class TableDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TableDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TableDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TableDSLPackage.EXTRACT:
				sequence_Extract(context, (Extract) semanticObject); 
				return; 
			case TableDSLPackage.FILTER:
				sequence_Filter(context, (Filter) semanticObject); 
				return; 
			case TableDSLPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case TableDSLPackage.RENAME_COLUMN:
				sequence_RenameColumn(context, (RenameColumn) semanticObject); 
				return; 
			case TableDSLPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case TableDSLPackage.SQUASH_ROWS:
				sequence_SquashRows(context, (SquashRows) semanticObject); 
				return; 
			case TableDSLPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case TableDSLPackage.TABLE_INPUT_PATH:
				sequence_TableInputPath(context, (TableInputPath) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableAction returns Extract
	 *     Operation returns Extract
	 *     Extract returns Extract
	 *
	 * Constraint:
	 *     placeholder=STRING
	 * </pre>
	 */
	protected void sequence_Extract(ISerializationContext context, Extract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TableDSLPackage.Literals.EXTRACT__PLACEHOLDER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TableDSLPackage.Literals.EXTRACT__PLACEHOLDER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtractAccess().getPlaceholderSTRINGTerminalRuleCall_1_0(), semanticObject.getPlaceholder());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableAction returns Filter
	 *     Operation returns Filter
	 *     Filter returns Filter
	 *
	 * Constraint:
	 *     placeholder=STRING
	 * </pre>
	 */
	protected void sequence_Filter(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TableDSLPackage.Literals.FILTER__PLACEHOLDER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TableDSLPackage.Literals.FILTER__PLACEHOLDER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilterAccess().getPlaceholderSTRINGTerminalRuleCall_2_0(), semanticObject.getPlaceholder());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableAction returns Output
	 *     Output returns Output
	 *
	 * Constraint:
	 *     outputPath=STRING
	 * </pre>
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TableDSLPackage.Literals.OUTPUT__OUTPUT_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TableDSLPackage.Literals.OUTPUT__OUTPUT_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputAccess().getOutputPathSTRINGTerminalRuleCall_2_0(), semanticObject.getOutputPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableAction returns RenameColumn
	 *     Operation returns RenameColumn
	 *     RenameColumn returns RenameColumn
	 *
	 * Constraint:
	 *     (oldName=STRING newName=STRING)
	 * </pre>
	 */
	protected void sequence_RenameColumn(ISerializationContext context, RenameColumn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TableDSLPackage.Literals.RENAME_COLUMN__OLD_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TableDSLPackage.Literals.RENAME_COLUMN__OLD_NAME));
			if (transientValues.isValueTransient(semanticObject, TableDSLPackage.Literals.RENAME_COLUMN__NEW_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TableDSLPackage.Literals.RENAME_COLUMN__NEW_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRenameColumnAccess().getOldNameSTRINGTerminalRuleCall_1_0(), semanticObject.getOldName());
		feeder.accept(grammarAccess.getRenameColumnAccess().getNewNameSTRINGTerminalRuleCall_3_0(), semanticObject.getNewName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableAction returns Select
	 *     Operation returns Select
	 *     Select returns Select
	 *
	 * Constraint:
	 *     columns+=STRING+
	 * </pre>
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableAction returns SquashRows
	 *     Operation returns SquashRows
	 *     SquashRows returns SquashRows
	 *
	 * Constraint:
	 *     column=STRING
	 * </pre>
	 */
	protected void sequence_SquashRows(ISerializationContext context, SquashRows semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TableDSLPackage.Literals.SQUASH_ROWS__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TableDSLPackage.Literals.SQUASH_ROWS__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSquashRowsAccess().getColumnSTRINGTerminalRuleCall_3_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Start returns Start
	 *
	 * Constraint:
	 *     ((actions+=CreateTable actions+=TableAction+) | actions+=TableAction+)?
	 * </pre>
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CreateTable returns TableInputPath
	 *     TableAction returns TableInputPath
	 *     LoadData returns TableInputPath
	 *     TableInputPath returns TableInputPath
	 *
	 * Constraint:
	 *     pathPatterns+=STRING+
	 * </pre>
	 */
	protected void sequence_TableInputPath(ISerializationContext context, TableInputPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
